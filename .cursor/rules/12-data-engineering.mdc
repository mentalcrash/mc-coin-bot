---
description: Data Engineering Standards (Pandas, VectorBT, DuckDB, Log Returns)
globs: **/data/*.py, **/backtest/*.py, **/analysis/*.py
alwaysApply: false
---

# ğŸ“Š Modern Data Engineering Standards (2026)

## 1. Vectorization Protocol (No Loops)
- **Zero Loop Policy:** ë°ì´í„° í”„ë ˆì„ì˜ í–‰(Row)ì„ ìˆœíšŒí•˜ëŠ” `for` ë¬¸, `iterrows()`, `itertuples()` ì‚¬ìš©ì„ **ì—„ê²©íˆ ê¸ˆì§€**í•©ë‹ˆë‹¤.
- **Vector Operations:**
    - ëª¨ë“  ì—°ì‚°ì€ Pandas/NumPyì˜ ë‚´ì¥ ë²¡í„° í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
    - ë³µì¡í•œ ë¡œì§ ì ìš© ì‹œì—ëŠ” `.apply()` ëŒ€ì‹  `numpy.where()`ë‚˜ `numpy.select()`ë¥¼ ìš°ì„  ê³ ë ¤í•©ë‹ˆë‹¤.
    - **VectorBT Usage:** ë°±í…ŒìŠ¤íŒ… ì‹œ ìº”ë“¤ í•˜ë‚˜í•˜ë‚˜ë¥¼ ë£¨í”„ ëŒì§€ ì•Šê³ , ì „ì²´ ë°°ì—´ì„ í•œ ë²ˆì— ê³„ì‚°í•˜ëŠ” **Broadcasting** ë°©ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

## 2. Pandas Modern Core (PyArrow Backed)
- **PyArrow Engine:** Pandas DataFrame ìƒì„± ì‹œ `dtype_backend='pyarrow'` ì˜µì…˜ì„ ì ê·¹ í™œìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì´ê³  ì†ë„ë¥¼ ë†’ì…ë‹ˆë‹¤.
    - ì˜ˆ: `pd.read_parquet(..., dtype_backend="pyarrow")`
- **Time Series Index:**
    - ëª¨ë“  ì‹œê³„ì—´ ë°ì´í„°ì˜ ì¸ë±ìŠ¤ëŠ” ë°˜ë“œì‹œ `DatetimeIndex`ì—¬ì•¼ í•©ë‹ˆë‹¤.
    - **UTC Only:** ëª¨ë“  ì‹œê°„ëŒ€ëŠ” `UTC`ë¡œ í†µì¼í•˜ì—¬ ì €ì¥ ë° ì²˜ë¦¬í•©ë‹ˆë‹¤. (`tz_localize('UTC')`)

## 3. Storage & I/O Strategy (Parquet & DuckDB)
- **No CSV:** ë°ì´í„° ì €ì¥ì€ ë°˜ë“œì‹œ **Parquet** í˜•ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
    - ì••ì¶• ì•Œê³ ë¦¬ì¦˜: ì…ì¶œë ¥ ì†ë„ì™€ ì••ì¶•ë¥  ë°¸ëŸ°ìŠ¤ê°€ ì¢‹ì€ `zstd` ë˜ëŠ” `snappy`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- **DuckDB Integration:**
    - ëŒ€ìš©ëŸ‰ ë°ì´í„°(ë©”ëª¨ë¦¬ë³´ë‹¤ í° íŒŒì¼)ë¥¼ ë¡œë“œí•  ë•ŒëŠ” `pandas.read_parquet`ìœ¼ë¡œ ì „ì²´ë¥¼ ì½ì§€ ë§ê³ , **DuckDB**ë¥¼ ì‚¬ìš©í•˜ì—¬ í•„ìš”í•œ ì»¬ëŸ¼ê³¼ ê¸°ê°„ë§Œ í•„í„°ë§(Pushdown Predicates)í•œ í›„ DataFrameìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    - SQL Query ì˜ˆì‹œ: `duckdb.query("SELECT * FROM 'data.parquet' WHERE date > '2026-01-01'").to_df()`

## 4. Return Calculation Protocol (Log vs Simple)
- **Internal Calculation (Math):**
    - ì „ëµ ê³„ì‚°, ë³€ë™ì„± ì¸¡ì •, ë¨¸ì‹ ëŸ¬ë‹ í•™ìŠµ ì‹œì—ëŠ” ë°˜ë“œì‹œ **ë¡œê·¸ ìˆ˜ìµë¥ (Log Returns)**ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
    - ê³µì‹: `np.log(df['close'] / df['close'].shift(1))`
    - ì´ìœ : ì‹œê°„ ê°€ì‚°ì„±(Time-Additivity)ê³¼ í†µê³„ì  ì •ê·œì„± í™•ë³´, ì—°ì‚° ì†ë„ í–¥ìƒ.
- **Reporting (Human):**
    - ìµœì¢… ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì£¼ê±°ë‚˜ `QuantStats` ë¦¬í¬íŠ¸ë¥¼ ìƒì„±í•  ë•ŒëŠ” **ë‹¨ìˆœ ìˆ˜ìµë¥ (Simple Returns)**ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    - ê³µì‹: `np.expm1(log_returns)` (ì •ë°€ë„ê°€ `np.exp(x) - 1` ë³´ë‹¤ ìš°ìˆ˜í•¨)

## 5. VectorBT (Backtesting) Rules
- **Indicator Construction:** ê¸°ìˆ ì  ì§€í‘œ ìƒì„± ì‹œ `vbt.IndicatorFactory`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë²¡í„°í™”ëœ ì§€í‘œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
- **Portfolio Simulation:**
    - `vbt.Portfolio.from_signals()` ë˜ëŠ” `vbt.Portfolio.from_orders()`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì „ì²´ ê¸°ê°„ì˜ ì‹œë®¬ë ˆì´ì…˜ì„ ë‹¨ì¼ ì—°ì‚°ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    - ëª¨ìˆ˜ ìµœì í™”(Parameter Optimization) ì‹œì—ëŠ” `vbt`ì˜ ë©€í‹° ì¸ë±ìŠ¤ ê¸°ëŠ¥ì„ í™œìš©í•˜ì—¬ ìˆ˜ì²œ ê°œì˜ ì „ëµì„ ë³‘ë ¬ë¡œ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.

## 6. Example Patterns

### âœ… Good (Vectorized, PyArrow & Log Returns)
```python
import pandas as pd
import duckdb
import vectorbt as vbt
import numpy as np

def load_process_backtest():
    # 1. Efficient Loading (DuckDB -> Pandas with PyArrow)
    df = duckdb.query("""
        SELECT timestamp, close 
        FROM 'market_data.parquet' 
        WHERE symbol = 'BTC/USDT' AND timestamp >= '2026-01-01'
    """).to_df()
    
    # 2. PyArrow Conversion & Indexing
    df = df.astype({'close': 'float64[pyarrow]'})
    df.set_index('timestamp', inplace=True)
    
    # 3. Log Return Calculation (For Internal Logic)
    # ë²¡í„° ì—°ì‚°ìœ¼ë¡œ ë¡œê·¸ ìˆ˜ìµë¥  ê³„ì‚°
    df['log_return'] = np.log(df['close'] / df['close'].shift(1))
    
    # ë³€ë™ì„± ê³„ì‚° (ë¡œê·¸ ìˆ˜ìµë¥  ê¸°ë°˜)
    volatility = df['log_return'].rolling(window=20).std()
    
    # 4. Strategy Logic (Numpy Select)
    conditions = [
        (df['log_return'] > 0.01), # 1% ì´ìƒ ìƒìŠ¹
        (df['log_return'] < -0.01) # 1% ì´ìƒ í•˜ë½
    ]
    choices = [1, -1]
    df['signal'] = np.select(conditions, choices, default=0)
    
    # 5. VectorBT Backtest
    # VBTëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ìˆ˜ìµë¥ ì„ ì˜ ì²˜ë¦¬í•˜ì§€ë§Œ, ì»¤ìŠ¤í…€ ì§€í‘œ ì‚¬ìš© ì‹œ ë¡œê·¸ ìˆ˜ìµë¥  í™œìš© ê¶Œì¥
    portfolio = vbt.Portfolio.from_signals(
        df['close'], 
        entries=(df['signal'] == 1), 
        exits=(df['signal'] == -1), 
        freq='1h'
    )
    
    # 6. Reporting (Convert back to Simple Return if needed manually)
    total_log_ret = df['log_return'].sum()
    total_simple_ret_pct = np.expm1(total_log_ret) * 100
    
    return portfolio.total_return()

```

### âŒ Bad (Loop-based & Arithmetic Returns)

```python
import pandas as pd

def slow_backtest():
    df = pd.read_csv('market_data.csv') 
    
    # ë‹¨ìˆœ ìˆ˜ìµë¥  ì‚¬ìš© (ì—°ì‚° ë¹„ìš© ë†’ìŒ)
    df['simple_return'] = df['close'].pct_change()
    
    # Iterrows ì‚¬ìš© (ìµœì•…ì˜ í¼í¬ë¨¼ìŠ¤)
    for index, row in df.iterrows():
        # ë³µë¦¬ ê³„ì‚°ì„ ë£¨í”„ë¡œ ì²˜ë¦¬í•˜ëŠ” ì•ˆí‹° íŒ¨í„´
        pass

```

```