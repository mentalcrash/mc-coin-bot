---
description: Data Engineering Standards (Pandas, VectorBT, DuckDB, Parquet)
globs: **/data/*.py, **/backtest/*.py, **/analysis/*.py
alwaysApply: false
---

# üìä Modern Data Engineering Standards (2026)

## 1. Vectorization Protocol (No Loops)
- **Zero Loop Policy:** Îç∞Ïù¥ÌÑ∞ ÌîÑÎ†àÏûÑÏùò Ìñâ(Row)ÏùÑ ÏàúÌöåÌïòÎäî `for` Î¨∏, `iterrows()`, `itertuples()` ÏÇ¨Ïö©ÏùÑ **ÏóÑÍ≤©Ìûà Í∏àÏßÄ**Ìï©ÎãàÎã§.
- **Vector Operations:**
    - Î™®Îì† Ïó∞ÏÇ∞ÏùÄ Pandas/NumPyÏùò ÎÇ¥Ïû• Î≤°ÌÑ∞ Ìï®ÏàòÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.
    - Î≥µÏû°Ìïú Î°úÏßÅ Ï†ÅÏö© ÏãúÏóêÎäî `.apply()` ÎåÄÏã† `numpy.where()`ÎÇò `numpy.select()`Î•º Ïö∞ÏÑ† Í≥†Î†§Ìï©ÎãàÎã§.
    - **VectorBT Usage:** Î∞±ÌÖåÏä§ÌåÖ Ïãú Ï∫îÎì§ ÌïòÎÇòÌïòÎÇòÎ•º Î£®ÌîÑ ÎèåÏßÄ ÏïäÍ≥†, Ï†ÑÏ≤¥ Î∞∞Ïó¥ÏùÑ Ìïú Î≤àÏóê Í≥ÑÏÇ∞ÌïòÎäî **Broadcasting** Î∞©ÏãùÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.

## 2. Pandas Modern Core (PyArrow Backed)
- **PyArrow Engine:** Pandas DataFrame ÏÉùÏÑ± Ïãú `dtype_backend='pyarrow'` ÏòµÏÖòÏùÑ Ï†ÅÍ∑π ÌôúÏö©ÌïòÏó¨ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏùÑ Ï§ÑÏù¥Í≥† ÏÜçÎèÑÎ•º ÎÜíÏûÖÎãàÎã§.
    - Ïòà: `pd.read_parquet(..., dtype_backend="pyarrow")`
- **Time Series Index:**
    - Î™®Îì† ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞Ïùò Ïù∏Îç±Ïä§Îäî Î∞òÎìúÏãú `DatetimeIndex`Ïó¨Ïïº Ìï©ÎãàÎã§.
    - **UTC Only:** Î™®Îì† ÏãúÍ∞ÑÎåÄÎäî `UTC`Î°ú ÌÜµÏùºÌïòÏó¨ Ï†ÄÏû• Î∞è Ï≤òÎ¶¨Ìï©ÎãàÎã§. (`tz_localize('UTC')`)

## 3. Storage & I/O Strategy (Parquet & DuckDB)
- **No CSV:** Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏùÄ Î∞òÎìúÏãú **Parquet** ÌòïÏãùÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.
    - ÏïïÏ∂ï ÏïåÍ≥†Î¶¨Ï¶ò: ÏûÖÏ∂úÎ†• ÏÜçÎèÑÏôÄ ÏïïÏ∂ïÎ•† Î∞∏Îü∞Ïä§Í∞Ä Ï¢ãÏùÄ `zstd` ÎòêÎäî `snappy`Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.
- **DuckDB Integration:**
    - ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞(Î©îÎ™®Î¶¨Î≥¥Îã§ ÌÅ∞ ÌååÏùº)Î•º Î°úÎìúÌï† ÎïåÎäî `pandas.read_parquet`ÏúºÎ°ú Ï†ÑÏ≤¥Î•º ÏùΩÏßÄ ÎßêÍ≥†, **DuckDB**Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÌïÑÏöîÌïú Ïª¨ÎüºÍ≥º Í∏∞Í∞ÑÎßå ÌïÑÌÑ∞ÎßÅ(Pushdown Predicates)Ìïú ÌõÑ DataFrameÏúºÎ°ú Î≥ÄÌôòÌï©ÎãàÎã§.
    - SQL Query ÏòàÏãú: `duckdb.query("SELECT * FROM 'data.parquet' WHERE date > '2026-01-01'").to_df()`

## 4. VectorBT (Backtesting) Rules
- **Indicator Construction:** Í∏∞Ïà†Ï†Å ÏßÄÌëú ÏÉùÏÑ± Ïãú `vbt.IndicatorFactory`Î•º ÏÇ¨Ïö©ÌïòÏó¨ Î≤°ÌÑ∞ÌôîÎêú ÏßÄÌëúÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
- **Portfolio Simulation:**
    - `vbt.Portfolio.from_signals()` ÎòêÎäî `vbt.Portfolio.from_orders()`Î•º ÏÇ¨Ïö©ÌïòÏó¨ Ï†ÑÏ≤¥ Í∏∞Í∞ÑÏùò ÏãúÎÆ¨Î†àÏù¥ÏÖòÏùÑ Îã®Ïùº Ïó∞ÏÇ∞ÏúºÎ°ú Ï≤òÎ¶¨Ìï©ÎãàÎã§.
    - Î™®Ïàò ÏµúÏ†ÅÌôî(Parameter Optimization) ÏãúÏóêÎäî `vbt`Ïùò Î©ÄÌã∞ Ïù∏Îç±Ïä§ Í∏∞Îä•ÏùÑ ÌôúÏö©ÌïòÏó¨ ÏàòÏ≤ú Í∞úÏùò Ï†ÑÎûµÏùÑ Î≥ëÎ†¨Î°ú ÌÖåÏä§Ìä∏Ìï©ÎãàÎã§.

## 5. Example Patterns

### ‚úÖ Good (Vectorized & Efficient)
```python
import pandas as pd
import duckdb
import vectorbt as vbt
import numpy as np

def load_and_backtest():
    # 1. Efficient Loading (DuckDB -> Pandas with PyArrow)
    # ÌïÑÏöîÌïú Îç∞Ïù¥ÌÑ∞Îßå ÏøºÎ¶¨Î°ú Ï∂îÏ∂ú
    df = duckdb.query("""
        SELECT timestamp, close 
        FROM 'market_data.parquet' 
        WHERE symbol = 'BTC/USDT' AND timestamp >= '2026-01-01'
    """).to_df()
    
    # 2. PyArrow Conversion & Indexing
    df = df.astype({'close': 'float64[pyarrow]'}) # Modern Type
    df.set_index('timestamp', inplace=True)
    
    # 3. Vectorized Calculation (No Loops)
    # Numpy selectÎ°ú Í≥†ÏÜç Ïó∞ÏÇ∞
    conditions = [
        (df['close'] > df['close'].shift(1)),
        (df['close'] < df['close'].shift(1))
    ]
    choices = [1, -1] # 1: Up, -1: Down
    df['direction'] = np.select(conditions, choices, default=0)
    
    # 4. VectorBT Backtest
    rsi = vbt.RSI.run(df['close'], window=14)
    entries = rsi.rsi_below(30)
    exits = rsi.rsi_above(70)
    
    portfolio = vbt.Portfolio.from_signals(df['close'], entries, exits, freq='1h')
    return portfolio.total_return()

```

### ‚ùå Bad (Loop-based & CSV)

```python
import pandas as pd

def slow_backtest():
    # CSV ÏÇ¨Ïö© Î∞è Ï†ÑÏ≤¥ Î°úÎìú
    df = pd.read_csv('market_data.csv') 
    
    # Iterrows ÏÇ¨Ïö© (ÏµúÏïÖÏùò ÌçºÌè¨Î®ºÏä§)
    for index, row in df.iterrows():
        if row['close'] > 100000:
             # Î°úÏßÅ Ï≤òÎ¶¨...
             pass

```