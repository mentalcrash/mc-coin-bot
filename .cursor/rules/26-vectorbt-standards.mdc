---
description: VectorBT Backtesting & Indicator Standards (Broadcasting, Numba)
globs: **/backtest/*.py, **/strategy/*.py, **/analysis/*.py
alwaysApply: false
---

# ðŸš€ VectorBT Standards (2026 High-Performance)

## 1. The Broadcasting Philosophy
- **No For-Loops:** ì „ëžµ íŒŒë¼ë¯¸í„°(ì˜ˆ: RSI ê¸°ê°„ 14, 15, 16...)ë¥¼ í…ŒìŠ¤íŠ¸í•  ë•Œ ì ˆëŒ€ `for` ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
- **Broadcasting:** íŒŒë¼ë¯¸í„°ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ì „ë‹¬í•˜ì—¬ VBTê°€ ë‚´ë¶€ì ìœ¼ë¡œ 3ì°¨ì› ë°°ì—´(Time x Assets x Parameters)ì„ ìƒì„±í•˜ë„ë¡ í•©ë‹ˆë‹¤.
    - âœ… `vbt.RSI.run(close, window=[14, 15, 16])`
    - âŒ `for w in [14, 15, 16]: vbt.RSI.run(..., window=w)`

## 2. Indicator Factory (Custom Indicators)
- **Factory Pattern:** `pandas-ta`ë‚˜ `talib` í•¨ìˆ˜ë¥¼ ë‹¨ìˆœížˆ í˜¸ì¶œí•˜ì§€ ë§ê³ , **`vbt.IndicatorFactory`**ë¡œ ëž˜í•‘í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.
    - ì´ìœ : ì´ë ‡ê²Œ í•´ì•¼ VBTì˜ ë¸Œë¡œë“œìºìŠ¤íŒ…, ìºì‹±, í”Œë¡œíŒ… ê¸°ëŠ¥ì„ ìƒì†ë°›ì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- **Numba Acceleration:** ì»¤ìŠ¤í…€ ì§€í‘œ ë¡œì§ì€ ë°˜ë“œì‹œ `@njit` (Numba) ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»´íŒŒì¼í•´ì•¼ í•©ë‹ˆë‹¤. ìˆœìˆ˜ Python í•¨ìˆ˜ëŠ” ëŒ€ëŸ‰ ë°±í…ŒìŠ¤íŒ… ì‹œ ë³‘ëª©ì´ ë©ë‹ˆë‹¤.

## 3. Portfolio Simulation Standards
- **Entry/Exit Signals:** `from_signals` ì‚¬ìš© ì‹œ, `entries`ì™€ `exits`ëŠ” ë°˜ë“œì‹œ `bool` íƒ€ìž…ì˜ DataFrameì´ì–´ì•¼ í•©ë‹ˆë‹¤.
- **Realistic Settings (Crucial):**
    - **Fees:** ìˆ˜ìˆ˜ë£Œ ì—†ëŠ” ë°±í…ŒìŠ¤íŒ…ì€ ì‚¬ê¸°ìž…ë‹ˆë‹¤. ë°˜ë“œì‹œ `fees` íŒŒë¼ë¯¸í„°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. (ì˜ˆ: ë°”ì´ë‚¸ìŠ¤ ê¸°ì¤€ `0.0004` ~ `0.001`)
    - **Slippage:** ì‹œìž¥ê°€ ì£¼ë¬¸ ì‹œ ìŠ¬ë¦¬í”¼ì§€ë¥¼ ê³ ë ¤í•˜ì—¬ `slippage` íŒŒë¼ë¯¸í„°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
    - **Freq:** ì—°í™˜ì‚° ìˆ˜ìµë¥ (Sharpe ë“±) ê³„ì‚°ì˜ ì •í™•ë„ë¥¼ ìœ„í•´ ë°ì´í„°ì˜ ì£¼ê¸°(`freq='1h'`, `'15m'` ë“±)ë¥¼ ë°˜ë“œì‹œ ëª…ì‹œí•©ë‹ˆë‹¤.
- **Look-Ahead Bias Prevention:** ì‹ í˜¸ ë°œìƒ ì‹œì (`close`)ê³¼ ì²´ê²° ì‹œì (`next open`)ì„ ì—„ê²©ížˆ êµ¬ë¶„í•©ë‹ˆë‹¤. (Rule `portfolio-manager.md` ì—°ë™)

## 4. Optimization & Memory Management
- **Chunking:** ìˆ˜ë§Œ ê°œì˜ íŒŒë¼ë¯¸í„° ì¡°í•©ì„ í…ŒìŠ¤íŠ¸í•  ë•ŒëŠ” ë©”ëª¨ë¦¬ í­ë°œ(OOM)ì„ ë§‰ê¸° ìœ„í•´ `chunked=True` ì˜µì…˜ì´ë‚˜ ì—”ì§„ ì„¤ì •ì„ í™œìš©í•©ë‹ˆë‹¤.
- **Parameter Selection:** ê²°ê³¼ ë¶„ì„ ì‹œ ë‹¨ìˆœížˆ 'ìˆ˜ìµë¥ (Total Return)'ë§Œ ë³´ì§€ ë§ê³ , **'Sharpe Ratio'**ì™€ **'Max Drawdown'**ì„ ë³µí•©ì ìœ¼ë¡œ ê³ ë ¤í•˜ëŠ” ížˆíŠ¸ë§µ(Heatmap)ì„ ìƒì„±í•©ë‹ˆë‹¤.

## 5. Example Pattern

### âœ… Good (Factory + Broadcasting + Numba)
```python
import vectorbt as vbt
import numpy as np
from numba import njit

# 1. Define Fast Logic with Numba
@njit
def custom_strategy_logic(close, window, threshold):
    # ë‹¨ìˆœ ì˜ˆì‹œ: ê°€ê²©ì´ ì´í‰ì„ ë³´ë‹¤ ë†’ê³  ë³€ë™ì„±ì´ threshold ì´ìƒì¼ ë•Œ
    ma = vbt.nb.rolling_mean_nb(close, window)
    return close > ma

# 2. Wrap with IndicatorFactory
MyStrategy = vbt.IndicatorFactory(
    class_name='MyStrategy',
    short_name='mystrat',
    input_names=['close'],
    param_names=['window', 'threshold'],
    output_names=['signal']
).from_apply_func(
    custom_strategy_logic, 
    keep_pd=True
)

def run_optimization(close_price_df):
    # 3. Broadcasting (Massive Sweep)
    # window 10~50, threshold 0.1~0.5 ëª¨ë“  ì¡°í•©(ìˆ˜ë°± ê°œ)ì„ í•œ ë²ˆì— ì‹¤í–‰
    strat = MyStrategy.run(
        close_price_df, 
        window=np.arange(10, 51), 
        threshold=[0.1, 0.3, 0.5],
        param_product=True # ëª¨ë“  ì¡°í•© í…ŒìŠ¤íŠ¸
    )
    
    # 4. Portfolio Simulation with Realism
    pf = vbt.Portfolio.from_signals(
        close=close_price_df,
        entries=strat.signal,
        exits=~strat.signal,
        fees=0.001,      # 0.1% fee
        slippage=0.0001, # 0.01% slippage
        freq='1h'        # Hourly data
    )
    
    # 5. Analysis
    return pf.total_return()

```

### âŒ Bad (Slow Loop & Unrealistic)

```python
import vectorbt as vbt

def slow_test(close_df):
    results = []
    # ëŠë¦° ë£¨í”„ ë°©ì‹
    for w in range(10, 50):
        # ìˆ˜ìˆ˜ë£Œ/ìŠ¬ë¦¬í”¼ì§€ ì„¤ì • ëˆ„ë½ -> ìˆ˜ìµë¥  ë»¥íŠ€ê¸°ë¨
        pf = vbt.Portfolio.from_signals(
            close_df, 
            entries=close_df > close_df.rolling(w).mean(),
            exits=close_df < close_df.rolling(w).mean()
        )
        results.append(pf.total_return())

```