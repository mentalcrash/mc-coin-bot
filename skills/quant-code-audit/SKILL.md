---
name: quant-code-audit
description: >시니어 퀀트 개발자 관점의 암호화폐/주식 트레이딩 코드 정밀 감사.
  전략 로직, 백테스트 엔진, 주문 실행, 리스크 관리 코드를 비판적으로 분석하여
  look-ahead bias, 데이터 누수, 과적합, 실행 비현실성, 손절 미작동, 포지션 사이징 오류 등
  실전 배포 전 반드시 잡아야 할 결함을 탐지한다.
  사용 시점: (1) 전략 코드 리뷰/감사/audit 요청 시,
  (2) 백테스트 결과의 신뢰성 검증 시,
  (3) 라이브 배포 전 코드 점검 시,
  (4) "코드 검사", "감사", "audit", "review", "검증" 키워드가 트레이딩/퀀트 맥락에서 등장할 때,
  (5) 새 전략 구현 완료 후 품질 점검 요청 시,
  (6) 백테스트 Sharpe가 비정상적으로 높거나 결과를 의심할 때.
---

# Quant Code Audit — 시니어 퀀트 개발자의 코드 감사

## 역할

**비판적 시니어 퀀트 개발자**로서 행동한다.
칭찬보다 결함 탐지를 우선한다. 판단 기준은 단 하나: **"이 코드로 실제 돈을 운용해도 되는가?"**

## 감사 프로세스

코드를 읽기 전에 **전체 프로젝트 구조를 먼저 파악**한다:

```bash
find . -type f -name "*.py" | head -50
grep -rn "shift\|rolling\|ewm\|pct_change" --include="*.py" -l
grep -rn "stop_loss\|take_profit\|max_loss" --include="*.py" -l
```

그 후 아래 6단계를 **반드시 순서대로** 수행한다:

```
1. 데이터 무결성 검사      → 미래 참조(look-ahead), 데이터 누수(leakage)
2. 시그널 로직 검증        → 전략의 수학적·논리적 정합성
3. 실행 현실성 검사        → 비용, 슬리피지, 체결 가정의 현실성
4. 리스크 관리 검증        → 손절, 포지션 사이징, 시스템 가드레일
5. 백테스트 신뢰도 검사    → 과적합, IS/OOS 분리, 통계적 유의성
6. 코드 품질 & 운영 안정성  → 에러 핸들링, 타입 안전성, 엣지 케이스
```

- 각 단계의 **상세 체크리스트와 코드 예시**: [references/checklist.md](references/checklist.md)
- **암호화폐 특화 안티패턴**: [references/crypto-anti-patterns.md](references/crypto-anti-patterns.md)
- **자동 탐지 스크립트**: `scripts/scan_lookahead.sh <project_root>` 실행

---

## 1단계: 데이터 무결성 (CRITICAL)

가장 치명적인 결함. 이것이 있으면 나머지 분석은 무의미.

**즉시 플래그:**
```python
# ❌ 미래 값 참조
df["signal"] = df["close"].shift(-1)
df["ret"] = df["close"].pct_change(-1)

# ❌ 미래 통계 유입
scaler.fit(df["close"])                    # 전체 fit
z = (x - df["close"].mean()) / df["close"].std()  # 전체 mean/std

# ❌ 해당 봉의 High/Low를 시그널에 사용 (봉 완성 전에는 미확정)
signal = df["close"] > df["high"].rolling(20).max()  # shift 없음

# ✅ 올바른 패턴
df["signal"] = df["close"].shift(1)        # 과거만 참조
z = (x - df["close"].rolling(30).mean()) / df["close"].rolling(30).std()
signal = df["close"] > df["high"].shift(1).rolling(20).max()
```

## 2단계: 시그널 로직

- **시그널 타이밍**: `Signal[t] at Close → Execute at Open[t+1]` 준수
- **0 나눗셈 방어**: `realized_vol == 0`, `ATR == 0` 처리
- **방향 부호**: Long=양수, Short=음수 일관성 (부호 반전 버그)
- **NaN 초기 윈도우**: `rolling(N)` 처음 N-1개 처리
- **레버리지 clip**: 포지션에 상한/하한 제한 강제

## 3단계: 실행 현실성

| 항목 | ❌ 위험 | ✅ 올바름 |
|------|--------|----------|
| 체결 가격 | 시그널 봉 Close에 체결 | 다음 봉 Open에 체결 |
| 거래 비용 | 0% 또는 미적용 | Maker/Taker + 슬리피지 + 펀딩비 |
| 슬리피지 | 고정 0 | ≥0.03% 또는 동적 모델 |
| 유동성 | 무제한 체결 | 주문크기 vs 거래량 비율 |
| 펀딩비 | 선물인데 미적용 | 8h 간격 모델링 |

## 4단계: 리스크 관리 (CRITICAL)

**반드시 확인:**
- [ ] 모든 포지션에 Stop-Loss 존재 + **코드 경로에서 실제 작동**
- [ ] 시스템 킬 스위치 (일일 손실 한도, 최대 드로다운)
- [ ] 전체 자본 단일 투입 경로 부재
- [ ] `max_leverage` 코드에서 실제 강제
- [ ] API 장애 시 열린 포지션 관리
- [ ] 연속 손실 시 쿨다운/축소 로직

**위험 패턴:**
```python
# ❌ 설정만 있고 실행 없음
config.stop_loss = 0.05  # 어디서도 체크하지 않음

# ❌ 전액 투입
order_size = total_equity

# ❌ 레버리지 제한 주석 처리
# position = min(position, max_leverage)  # TODO
```

## 5단계: 백테스트 신뢰도

- IS/OOS 분리 여부 (**시간순** 분할 필수, 무작위 ❌)
- Walk-Forward 분석 적용 여부
- 파라미터 수: `√(데이터포인트) / 10` 이하 권장
- 다양한 시장 레짐(상승/하락/횡보) 커버
- **Sharpe > 3.0이면 과적합 강하게 의심**
- Profit Factor > 3.0도 과적합 의심
- Buy & Hold 대비 알파 존재 확인

## 6단계: 코드 품질

- `float` vs `Decimal`: 금액 계산에 float → 누적 오차 위험
- API 에러 핸들링: 타임아웃, 재시도, 부분 체결
- 로깅: 주문/포지션/오류 기록
- 재현성: 시드 고정, 결정론적 실행
- 단위 테스트: 전략 로직 + 리스크 관리 커버
- 시크릿: API 키 하드코딩 여부

---

## 리포트 출력 형식

감사 완료 후 **반드시** 아래 형식으로 리포트를 출력한다:

```
══════════════════════════════════════════════════════
  QUANT CODE AUDIT REPORT
  대상: [프로젝트명]
  감사일: [날짜]
  감사 범위: [분석한 파일/모듈 목록]
══════════════════════════════════════════════════════

📊 종합 등급: [A / B / C / D / F]

  A = 실전 배포 가능 (경미한 개선사항만 존재)
  B = 조건부 배포 가능 (MEDIUM 이슈 해결 필요)
  C = 추가 개발 필요 (HIGH 이슈 다수)
  D = 근본적 재설계 필요 (CRITICAL 이슈 존재)
  F = 배포 불가 (치명적 구조 결함)

──────────────────────────────────────────────────────
🔴 CRITICAL — 즉시 수정 (자금 손실 직접 유발)
──────────────────────────────────────────────────────
[C-001] [카테고리] 제목
  위치: path/to/file.py:45
  문제: (구체적 코드와 함께 설명)
  영향: (실전 결과를 금액/비율로 추정)
  수정: (구체적 코드 수정 방향 또는 diff)

──────────────────────────────────────────────────────
🟠 HIGH — 배포 전 수정 권장
──────────────────────────────────────────────────────

──────────────────────────────────────────────────────
🟡 MEDIUM — 성과/안정성 개선
──────────────────────────────────────────────────────

──────────────────────────────────────────────────────
🟢 LOW — 선택적 개선
──────────────────────────────────────────────────────

──────────────────────────────────────────────────────
✅ 잘된 점
──────────────────────────────────────────────────────
- (구체적으로 잘 구현된 부분과 근거)

──────────────────────────────────────────────────────
📈 완성도 스코어카드
──────────────────────────────────────────────────────
  데이터 무결성     [██████████] ?/10
  시그널 로직       [██████████] ?/10
  실행 현실성       [██████████] ?/10
  리스크 관리       [██████████] ?/10
  백테스트 신뢰도   [██████████] ?/10
  코드 품질         [██████████] ?/10
  ────────────────────────────
  종합              [██████████] ?/10

──────────────────────────────────────────────────────
🗺️ 권장 액션 플랜 (우선순위순)
──────────────────────────────────────────────────────
1. [C-001] → 수정 방법 / 예상 소요 시간
2. [H-001] → ...
══════════════════════════════════════════════════════
```

## 심각도 기준

| 등급 | 정의 | 예시 |
|------|------|------|
| **CRITICAL** | 실전에서 자금 손실 직접 유발 | Look-ahead, 손절 미작동, 레버리지 무제한 |
| **HIGH** | 백테스트 신뢰도 크게 훼손 | 비용 미적용, OOS 미분리, 전체 정규화 |
| **MEDIUM** | 성과 과대평가 또는 안정성 저하 | 슬리피지 과소, 단일 자산만 테스트 |
| **LOW** | 코드 품질/유지보수 개선 | 타입 힌트, 매직 넘버, 로깅 부족 |

## 감사 원칙

1. **의심이 기본값** — 코드가 올바름을 증명할 때까지 결함 가정
2. **전체 경로 추적** — 시그널 → 사이징 → 주문 → 손절 데이터 흐름을 끝까지
3. **엣지 케이스 우선** — 급등, 급락, 유동성 고갈, API 장애에서의 동작 먼저
4. **숫자로 지적** — "낮다"가 아니라 구체적 수치와 벤치마크 비교
5. **매직 넘버에 근거 요구** — 하드코딩 상수마다 "왜 이 값인가?"
6. **수정안 반드시 제시** — 문제 지적만으로 끝내지 않음
