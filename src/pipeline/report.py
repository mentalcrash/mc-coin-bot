"""Dashboard generator and console renderer for strategy pipeline.

DashboardGenerator: YAML → markdown 파일 생성 (--output 옵션용).
ConsoleRenderer: YAML → Rich 콘솔 출력 (기본 모드).
"""

from __future__ import annotations

from rich.console import Console
from rich.table import Table

from src.pipeline.lesson_store import LessonStore
from src.pipeline.models import (
    PhaseId,
    PhaseVerdict,
    StrategyRecord,
    StrategyStatus,
)
from src.pipeline.phase_criteria_models import PhaseCriteria, PhaseType
from src.pipeline.phase_criteria_store import PhaseCriteriaStore
from src.pipeline.store import StrategyStore


class DashboardGenerator:
    """YAML 데이터 → dashboard.md 생성."""

    def __init__(
        self,
        store: StrategyStore,
        lesson_store: LessonStore | None = None,
        phase_store: PhaseCriteriaStore | None = None,
    ) -> None:
        self.store = store
        self.lesson_store = lesson_store
        self.phase_store = phase_store

    def generate(self) -> str:
        """전체 dashboard markdown 생성."""
        records = self.store.load_all()
        active = [r for r in records if r.meta.status == StrategyStatus.ACTIVE]
        retired = [r for r in records if r.meta.status == StrategyStatus.RETIRED]

        sections = [
            self._header(len(records), len(active), len(retired)),
            self._pipeline_diagram(),
            self._phase_criteria_table(),
            self._cost_model_table(),
            self._strategy_summary(len(records), len(active), len(retired)),
            self._active_table(active),
            self._retired_sections(retired),
            self._lessons(),
        ]
        return "\n\n---\n\n".join(s for s in sections if s)

    # ─── Static sections ──────────────────────────────────────────

    def _header(self, total: int, active: int, retired: int) -> str:
        return (
            "<!-- AUTO-GENERATED by `pipeline report --output` — 수동 편집 금지 -->\n\n"
            "# 전략 상황판 (Strategy Dashboard)\n\n"
            f"> {total}개 전략의 평가 현황과 검증 기준을 한눈에 파악하는 문서. "
            f"(활성 {active} + 폐기 {retired})\n"
            "> Phase 기준은 `pipeline phases-list/phases-show`로 확인."
        )

    def _pipeline_diagram(self) -> str:
        return (
            "## 평가 파이프라인\n\n"
            "```\n"
            "Phase 1 → Phase 2 → Phase 3 → Phase 4 → Phase 5 → Phase 6 → Phase 7\n"
            "Alpha    구현     코드검증  백테스트  로버스트  심층검증   라이브\n"
            "```"
        )

    def _phase_criteria_table(self) -> str:
        if self.phase_store is not None:
            return self._generate_phase_criteria_table()
        return self._static_phase_criteria_table()

    def _generate_phase_criteria_table(self) -> str:
        """PhaseCriteriaStore → 동적 Phase 기준 테이블."""
        assert self.phase_store is not None
        phases = self.phase_store.load_all()
        lines = [
            "### Phase별 통과 기준\n",
            "| Phase | 검증 | 핵심 기준 | CLI |",
            "|:-----:|------|----------|-----|",
        ]
        for p in phases:
            cli = f"`{p.cli_command}`" if p.cli_command else "—"
            criteria_text = _summarize_criteria(p)
            lines.append(f"| **{p.phase_id}** | {p.name} | {criteria_text} | {cli} |")
        return "\n".join(lines)

    @staticmethod
    def _static_phase_criteria_table() -> str:
        """Fallback: 하드코딩 Phase 기준 테이블."""
        return (
            "### Phase별 통과 기준\n\n"
            "| Phase | 검증 | 핵심 기준 | CLI |\n"
            "|:-----:|------|----------|-----|\n"
            "| **P1** | Alpha Research | 6항목 합계 >= 21/30 | — |\n"
            "| **P2** | Implementation | 4-file 구조 완성 | `/p2-implement` |\n"
            "| **P3** | Code Audit | Critical 7항목 결함 0개 | `/p3-g0b-verify` |\n"
            "| **P4** | Backtest | Sharpe > 1.0, CAGR > 20%, MDD < 40%, OOS Sharpe >= 0.3 | `run {config}` |\n"
            "| **P5** | Robustness | 파라미터 고원 + ±20% 안정 | `pipeline phase5-run` |\n"
            "| **P6** | Deep Validation | WFA OOS >= 0.5, DSR > 0.95 | `validate -m milestone/final` |\n"
            "| **P7** | Live Readiness | VBT vs EDA 수익 부호 일치, 편차 < 20% | `eda run {config}` |"
        )

    def _cost_model_table(self) -> str:
        from src.portfolio.cost_model import CostModel

        cm = CostModel.binance_futures()
        total = cm.total_fee_rate
        return (
            "### 비용 모델\n\n"
            "| 항목 | 값 | 항목 | 값 |\n"
            "|------|---:|------|---:|\n"
            f"| Maker Fee | {cm.maker_fee:.2%} | Slippage | {cm.slippage:.2%} |\n"
            f"| Taker Fee | {cm.taker_fee:.2%} | Funding (8h) | {cm.funding_rate_8h:.2%} |\n"
            f"| Market Impact | {cm.market_impact:.2%} | **편도 합계** | **~{total:.2%}** |"
        )

    # ─── Dynamic sections ─────────────────────────────────────────

    def _strategy_summary(self, total: int, active: int, retired: int) -> str:
        return f"## 현재 전략 현황 ({total}개 = 활성 {active} + 폐기 {retired})"

    def _active_table(self, active: list[StrategyRecord]) -> str:
        if not active:
            return "### 활성 전략 (0개)"

        lines = [
            f"### 활성 전략 ({len(active)}개, Phase 7 완료)\n",
            "| 전략 | Best Asset | TF | Sharpe | CAGR | MDD | Trades | P1 | P4 | P5 | P6 | P7 | 비고 |",
            "|------|-----------|-----|--------|------|-----|--------|:--:|:--:|:--:|:--:|:--:|------|",
        ]

        for r in sorted(active, key=lambda x: -(x.best_sharpe or 0)):
            best = max(r.asset_performance, key=lambda a: a.sharpe) if r.asset_performance else None
            if best:
                phases_str = " | ".join(
                    _phase_letter(r, pid)
                    for pid in [PhaseId.P1, PhaseId.P4, PhaseId.P5, PhaseId.P6, PhaseId.P7]
                )
                note = _extract_note(r)
                cagr = f"+{best.cagr:.1f}%" if best.cagr > 0 else f"{best.cagr:.1f}%"
                row = (
                    f"| **{r.meta.display_name}** | {best.symbol} | {r.meta.timeframe} | "
                    + f"{best.sharpe:.2f} | {cagr} | -{best.mdd:.1f}% | {best.trades} | "
                    + f"{phases_str} | {note} |"
                )
                lines.append(row)

        # 활성 전략 상세 노트 (마지막 decision의 rationale)
        notes = []
        for r in sorted(active, key=lambda x: -(x.best_sharpe or 0)):
            last_decision = r.decisions[-1] if r.decisions else None
            if last_decision:
                notes.append(f"> **{r.meta.display_name}**: {last_decision.rationale}")
        if notes:
            lines.append("")
            lines.extend(notes)

        return "\n".join(lines)

    def _retired_sections(self, retired: list[StrategyRecord]) -> str:
        """폐기 전략을 fail phase별로 분류."""
        sections: list[str] = [f"### 폐기 전략 ({len(retired)}개)\n"]
        phase_groups = self.group_retired(retired)
        self._append_group_tables(phase_groups, sections)
        return "\n\n".join(sections)

    def group_retired(
        self,
        retired: list[StrategyRecord],
    ) -> dict[str, list[StrategyRecord]]:
        """폐기 전략을 fail phase별 그룹으로 분류."""
        groups: dict[str, list[StrategyRecord]] = {
            "P6": [],
            "P5": [],
            "P4_oos": [],
            "P4_sharpe": [],
            "P4_negative": [],
            "P4_data": [],
            "P4_structural": [],
        }
        for r in retired:
            fp = r.fail_phase
            if fp == "P6":
                groups["P6"].append(r)
            elif fp == "P5":
                groups["P5"].append(r)
            elif fp == "P4":
                self._classify_p4_fail(r, groups)
            else:
                groups["P4_structural"].append(r)
        return groups

    def _append_group_tables(
        self,
        groups: dict[str, list[StrategyRecord]],
        sections: list[str],
    ) -> None:
        """그룹별 테이블을 sections에 추가."""
        renderers = [
            ("P6", self._p6_fail_table),
            ("P5", self._p5_fail_table),
            ("P4_oos", self._p4_oos_fail_table),
            ("P4_sharpe", self._p4_sharpe_fail_table),
            ("P4_negative", self._p4_negative_fail_table),
            ("P4_data", self._p4_data_fail_table),
            ("P4_structural", self._p4_structural_fail_table),
        ]
        for key, renderer in renderers:
            if groups[key]:
                sections.append(renderer(groups[key]))

    def _classify_p4_fail(
        self,
        r: StrategyRecord,
        groups: dict[str, list[StrategyRecord]],
    ) -> None:
        """P4 FAIL 전략을 세부 카테고리로 분류."""
        if not r.asset_performance:
            groups["P4_data"].append(r)
            return

        best = max(r.asset_performance, key=lambda a: a.sharpe)

        # All negative or near-zero
        all_negative = all(a.sharpe <= 0 for a in r.asset_performance)
        if all_negative or best.sharpe < 0:
            groups["P4_negative"].append(r)
        elif best.sharpe < 1.0 and best.cagr > 0:
            groups["P4_sharpe"].append(r)
        else:
            groups["P4_structural"].append(r)

    def _p6_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Phase 6 실패 -- WFA 심층검증\n",
            "| 전략 | Sharpe | 사유 |",
            "|------|--------|------|",
        ]
        for r in sorted(records, key=lambda x: -(x.best_sharpe or 0)):
            link = r.meta.display_name
            sharpe = f"{r.best_sharpe:.2f}" if r.best_sharpe else "-"
            note = _fail_rationale(r, PhaseId.P6)
            lines.append(f"| {link} | {sharpe} | {note} |")
        return "\n".join(lines)

    def _p5_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Phase 5 실패 -- 파라미터 불안정\n",
            "| 전략 | Sharpe | 사유 |",
            "|------|--------|------|",
        ]
        for r in records:
            link = r.meta.display_name
            sharpe = f"{r.best_sharpe:.2f}" if r.best_sharpe else "-"
            note = _fail_rationale(r, PhaseId.P5)
            lines.append(f"| {link} | {sharpe} | {note} |")
        return "\n".join(lines)

    def _p4_oos_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            f"#### Phase 4 실패 -- IS/OOS 과적합 ({len(records)}개)\n",
            "| 전략 | Sharpe | OOS Sharpe | Decay |",
            "|------|--------|-----------|-------|",
        ]
        for r in sorted(records, key=lambda x: -(x.best_sharpe or 0)):
            link = r.meta.display_name
            sharpe = f"{r.best_sharpe:.2f}" if r.best_sharpe else "-"
            p4 = r.phases.get(PhaseId.P4)
            oos = f"{p4.details.get('oos_sharpe', '-')}" if p4 else "-"
            decay = f"{p4.details.get('decay', '-')}%" if p4 and "decay" in p4.details else "-"
            lines.append(f"| {link} | {sharpe} | {oos} | {decay} |")
        return "\n".join(lines)

    def _p4_sharpe_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Phase 4 실패 -- Sharpe/CAGR 미달\n",
            "| 전략 | Sharpe | CAGR | 사유 |",
            "|------|--------|------|------|",
        ]
        for r in sorted(records, key=lambda x: -(x.best_sharpe or 0)):
            link = r.meta.display_name
            best = max(r.asset_performance, key=lambda a: a.sharpe) if r.asset_performance else None
            sharpe = f"{best.sharpe:.2f}" if best else "-"
            cagr = (
                f"+{best.cagr:.1f}%"
                if best and best.cagr > 0
                else (f"{best.cagr:.1f}%" if best else "-")
            )
            note = _fail_rationale(r, PhaseId.P4)
            lines.append(f"| {link} | {sharpe} | {cagr} | {note} |")
        return "\n".join(lines)

    def _p4_negative_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Phase 4 실패 -- 전 에셋 Sharpe 음수/0 근접\n",
            "| 전략 | Sharpe | CAGR | 사유 |",
            "|------|--------|------|------|",
        ]
        for r in sorted(records, key=lambda x: -(x.best_sharpe or 0)):
            link = r.meta.display_name
            best = max(r.asset_performance, key=lambda a: a.sharpe) if r.asset_performance else None
            sharpe = f"{best.sharpe:.2f}" if best else "-"
            cagr = (
                f"+{best.cagr:.1f}%"
                if best and best.cagr > 0
                else (f"{best.cagr:.1f}%" if best else "-")
            )
            note = _fail_rationale(r, PhaseId.P4)
            lines.append(f"| {link} | {sharpe} | {cagr} | {note} |")
        return "\n".join(lines)

    def _p4_data_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Phase 4 실패 -- 데이터 부재 / 인프라 미구축\n",
            "| 전략 | P1 점수 | 사유 |",
            "|------|---------|------|",
        ]
        for r in records:
            link = r.meta.display_name
            p1 = r.phases.get(PhaseId.P1)
            if p1:
                p1_max = p1.details.get("max_score", 30)
                score = f"{p1.details.get('score', '?')}/{p1_max}"
            else:
                score = "-"
            note = _fail_rationale(r, PhaseId.P4)
            lines.append(f"| {link} | {score} | {note} |")
        return "\n".join(lines)

    def _p4_structural_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Phase 4 실패 -- 구조적 결함\n",
            "| 전략 | Sharpe | 사유 |",
            "|------|--------|------|",
        ]
        for r in records:
            link = r.meta.display_name
            sharpe = f"{r.best_sharpe:.2f}" if r.best_sharpe else "-"
            note = _fail_rationale(r, PhaseId.P4)
            lines.append(f"| {link} | {sharpe} | {note} |")
        return "\n".join(lines)

    def _lessons(self) -> str:
        """핵심 교훈 (LessonStore에서 생성)."""
        if self.lesson_store is not None:
            return self._generate_lessons_table()
        return ""

    def _generate_lessons_table(self) -> str:
        """LessonStore → markdown 테이블 생성."""
        assert self.lesson_store is not None
        records = self.lesson_store.load_all()
        if not records:
            return "## 핵심 교훈\n\n(없음)"
        lines = [
            "## 핵심 교훈\n",
            "| # | 교훈 |",
            "|---|------|",
            *[f"| {r.id} | **{r.title}**: {r.body} |" for r in records],
        ]
        return "\n".join(lines)


# ─── Helpers ─────────────────────────────────────────────────────────


def _summarize_criteria(p: PhaseCriteria) -> str:
    """PhaseCriteria → 1줄 요약 텍스트."""
    if p.phase_type == PhaseType.SCORING and p.scoring:
        n = len(p.scoring.items)
        return f"{n}항목 합계 >= {p.scoring.pass_threshold}/{p.scoring.max_total}"
    if p.phase_type == PhaseType.CHECKLIST and p.checklist:
        return p.checklist.pass_rule
    if p.phase_type == PhaseType.THRESHOLD and p.threshold:
        parts = []
        for m in p.threshold.pass_metrics:
            val_str = str(int(m.value)) if m.value == int(m.value) else str(m.value)
            parts.append(f"{m.name} {m.operator} {val_str}{m.unit}")
        return ", ".join(parts)
    return ""


def _phase_letter(record: StrategyRecord, pid: PhaseId) -> str:
    """Phase 결과를 P/F/- 단일 문자로."""
    result = record.phases.get(pid)
    if result is None:
        return " "
    return "P" if result.status == PhaseVerdict.PASS else "F"


def _extract_note(record: StrategyRecord) -> str:
    """활성 전략의 비고."""
    p6 = record.phases.get(PhaseId.P6)
    if p6 and "note" in p6.details:
        return str(p6.details["note"])
    return ""


def _fail_rationale(record: StrategyRecord, phase: PhaseId) -> str:
    """FAIL 사유 추출 — decisions.rationale 우선."""
    # 1. decisions에서 해당 phase의 rationale 탐색
    for d in reversed(record.decisions):
        if d.phase == phase:
            return d.rationale

    # 2. fallback: phases.details
    result = record.phases.get(phase)
    if not result:
        return ""
    note = result.details.get("note", "")
    if note:
        return str(note)
    # Build from structured details
    parts = []
    if "sharpe" in result.details:
        parts.append(f"Sharpe {result.details['sharpe']}")
    if "cagr" in result.details:
        parts.append(f"CAGR {result.details['cagr']}%")
    return ", ".join(parts) if parts else ""


def _phase_badge(record: StrategyRecord, pid: PhaseId) -> str:
    """Phase 결과를 Rich 색상 문자로 변환."""
    result = record.phases.get(pid)
    if result is None:
        return "[dim]-[/dim]"
    if result.status == PhaseVerdict.PASS:
        return "[green]P[/green]"
    return "[red]F[/red]"


_PHASE_DISPLAY = ("P1", "P2", "P3", "P4", "P5", "P6", "P7")

_RETIRED_GROUP_LABELS: dict[str, str] = {
    "P6": "P6 WFA 심층검증",
    "P5": "P5 파라미터 불안정",
    "P4_oos": "P4 IS/OOS 과적합",
    "P4_sharpe": "P4 Sharpe/CAGR 미달",
    "P4_negative": "P4 전 에셋 Sharpe 음수",
    "P4_data": "P4 데이터 부재",
    "P4_structural": "P4 구조적 결함",
}


class ConsoleRenderer:
    """YAML 데이터 → Rich 콘솔 출력."""

    def __init__(
        self,
        store: StrategyStore,
        lesson_store: LessonStore | None = None,
        phase_store: PhaseCriteriaStore | None = None,
        console: Console | None = None,
    ) -> None:
        self.store = store
        self.lesson_store = lesson_store
        self.phase_store = phase_store
        self.console = console or Console()

    def render(self) -> None:
        """콘솔에 전략 상황판 출력."""
        records = self.store.load_all()
        active = [r for r in records if r.meta.status == StrategyStatus.ACTIVE]
        retired = [r for r in records if r.meta.status == StrategyStatus.RETIRED]

        self._render_header(len(records), len(active), len(retired))
        self._render_active(active)
        self._render_retired_summary(retired)
        self._render_lessons()

    def _render_header(self, total: int, active: int, retired: int) -> None:
        self.console.print()
        self.console.print("[bold]Strategy Dashboard[/bold]")
        line = f"  [green]Active: {active}[/green] | [red]Retired: {retired}[/red] | Total: {total}"
        self.console.print(line)

    def _render_active(self, active: list[StrategyRecord]) -> None:
        if not active:
            self.console.print("\n[yellow]No active strategies.[/yellow]")
            return

        table = Table(
            title=f"Active Strategies ({len(active)})",
            show_header=True,
            header_style="bold",
            show_lines=False,
        )
        table.add_column("Strategy", style="bold", min_width=12)
        table.add_column("Best Asset", width=11)
        table.add_column("TF", width=4)
        table.add_column("Sharpe", justify="right", width=7)
        table.add_column("CAGR", justify="right", width=8)
        table.add_column("MDD", justify="right", width=7)
        table.add_column("Trades", justify="right", width=7)
        for pname in _PHASE_DISPLAY:
            table.add_column(pname, justify="center", width=3)

        for r in sorted(active, key=lambda x: -(x.best_sharpe or 0)):
            best = max(r.asset_performance, key=lambda a: a.sharpe) if r.asset_performance else None
            if not best:
                continue
            cagr = f"+{best.cagr:.1f}%" if best.cagr > 0 else f"{best.cagr:.1f}%"
            phase_cells = [_phase_badge(r, PhaseId(p)) for p in _PHASE_DISPLAY]
            table.add_row(
                r.meta.display_name,
                best.symbol,
                r.meta.timeframe,
                f"{best.sharpe:.2f}",
                cagr,
                f"-{best.mdd:.1f}%",
                str(best.trades),
                *phase_cells,
            )

        self.console.print()
        self.console.print(table)

        # 활성 전략 노트
        for r in sorted(active, key=lambda x: -(x.best_sharpe or 0)):
            last = r.decisions[-1] if r.decisions else None
            if last:
                self.console.print(f"  [dim]{r.meta.display_name}:[/dim] {last.rationale}")

    def _render_retired_summary(self, retired: list[StrategyRecord]) -> None:
        if not retired:
            return

        gen = DashboardGenerator(self.store)
        groups = gen.group_retired(retired)

        self.console.print()
        self.console.print(f"[bold]Retired Strategies ({len(retired)})[/bold]")

        parts = []
        for key, label in _RETIRED_GROUP_LABELS.items():
            count = len(groups.get(key, []))
            if count:
                parts.append(f"  {label}: {count}")
        self.console.print("\n".join(parts))

    def _render_lessons(self) -> None:
        if self.lesson_store is None:
            return
        records = self.lesson_store.load_all()
        if not records:
            return

        table = Table(
            title=f"Lessons ({len(records)})",
            show_header=True,
            header_style="bold",
            show_lines=False,
        )
        table.add_column("#", style="dim", width=3)
        table.add_column("Title", style="bold", min_width=20)
        table.add_column("Category", width=18)

        for r in records:
            table.add_row(str(r.id), r.title, r.category.value)

        self.console.print()
        self.console.print(table)
