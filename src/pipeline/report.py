"""Dashboard generator and console renderer for strategy pipeline.

DashboardGenerator: YAML → markdown 파일 생성 (--output 옵션용).
ConsoleRenderer: YAML → Rich 콘솔 출력 (기본 모드).
"""

from __future__ import annotations

from rich.console import Console
from rich.table import Table

from src.pipeline.gate_models import GateCriteria, GateType
from src.pipeline.gate_store import GateCriteriaStore
from src.pipeline.lesson_store import LessonStore
from src.pipeline.models import (
    GateId,
    GateVerdict,
    StrategyRecord,
    StrategyStatus,
)
from src.pipeline.store import StrategyStore


class DashboardGenerator:
    """YAML 데이터 → dashboard.md 생성."""

    def __init__(
        self,
        store: StrategyStore,
        lesson_store: LessonStore | None = None,
        gate_store: GateCriteriaStore | None = None,
    ) -> None:
        self.store = store
        self.lesson_store = lesson_store
        self.gate_store = gate_store

    def generate(self) -> str:
        """전체 dashboard markdown 생성."""
        records = self.store.load_all()
        active = [r for r in records if r.meta.status == StrategyStatus.ACTIVE]
        retired = [r for r in records if r.meta.status == StrategyStatus.RETIRED]

        sections = [
            self._header(len(records), len(active), len(retired)),
            self._pipeline_diagram(),
            self._gate_criteria_table(),
            self._cost_model_table(),
            self._strategy_summary(len(records), len(active), len(retired)),
            self._active_table(active),
            self._retired_sections(retired),
            self._lessons(),
        ]
        return "\n\n---\n\n".join(s for s in sections if s)

    # ─── Static sections ──────────────────────────────────────────

    def _header(self, total: int, active: int, retired: int) -> str:
        return (
            "<!-- AUTO-GENERATED by `pipeline report --output` — 수동 편집 금지 -->\n\n"
            "# 전략 상황판 (Strategy Dashboard)\n\n"
            f"> {total}개 전략의 평가 현황과 검증 기준을 한눈에 파악하는 문서. "
            f"(활성 {active} + 폐기 {retired})\n"
            "> Gate 기준은 `pipeline gates-list/gates-show`로 확인."
        )

    def _pipeline_diagram(self) -> str:
        return (
            "## 평가 파이프라인\n\n"
            "```\n"
            "Gate 0A → Gate 0B → Gate 1 → Gate 2 → Gate 3 → Gate 4 → Gate 5 → Gate 6 → Gate 7\n"
            "아이디어   코드검증  백테스트  IS/OOS   파라미터  심층검증   EDA     Paper   실전배포\n"
            "```"
        )

    def _gate_criteria_table(self) -> str:
        if self.gate_store is not None:
            return self._generate_gate_criteria_table()
        return self._static_gate_criteria_table()

    def _generate_gate_criteria_table(self) -> str:
        """GateCriteriaStore → 동적 Gate 기준 테이블."""
        assert self.gate_store is not None
        gates = self.gate_store.load_all()
        lines = [
            "### Gate별 통과 기준\n",
            "| Gate | 검증 | 핵심 기준 | CLI |",
            "|:----:|------|----------|-----|",
        ]
        for g in gates:
            gid_short = g.gate_id.replace("G0", "0").replace("G", "")
            cli = f"`{g.cli_command}`" if g.cli_command else "—"
            criteria_text = _summarize_criteria(g)
            lines.append(f"| **{gid_short}** | {g.name} | {criteria_text} | {cli} |")
        return "\n".join(lines)

    @staticmethod
    def _static_gate_criteria_table() -> str:
        """Fallback: 하드코딩 Gate 기준 테이블."""
        return (
            "### Gate별 통과 기준\n\n"
            "| Gate | 검증 | 핵심 기준 | CLI |\n"
            "|:----:|------|----------|-----|\n"
            "| **0A** | 아이디어 검증 | 6항목 합계 >= 18/30 | — |\n"
            "| **0B** | 코드 품질 검증 | Critical 7항목 결함 0개 | `/p3-g0b-verify` |\n"
            "| **1** | 단일에셋 백테스트 (5코인 x 6년) | Sharpe > 1.0, CAGR > 20%, MDD < 40%, Trades > 50 | `run {config}` |\n"
            "| **2** | IS/OOS 70/30 | OOS Sharpe >= 0.3, Decay < 50% | `validate -m quick` |\n"
            "| **3** | 파라미터 안정성 | 고원 존재, ±20% Sharpe 부호 유지 | `sweep {config}` |\n"
            "| **4** | WFA + CPCV + PBO + DSR | WFA OOS >= 0.5, PBO 이중 경로, DSR > 0.95 | `validate -m milestone/final` |\n"
            "| **5** | EDA Parity | VBT vs EDA 수익 부호 일치, 편차 < 20% | `eda run {config}` |\n"
            "| **6** | Paper Trading (2주+) | 시그널 일치 > 90%, 무중단 | `eda run-live` |\n"
            "| **7** | 실전 배포 | 3개월 이동 Sharpe > 0.3 | — |"
        )

    def _cost_model_table(self) -> str:
        from src.portfolio.cost_model import CostModel

        cm = CostModel.binance_futures()
        total = cm.total_fee_rate
        return (
            "### 비용 모델\n\n"
            "| 항목 | 값 | 항목 | 값 |\n"
            "|------|---:|------|---:|\n"
            f"| Maker Fee | {cm.maker_fee:.2%} | Slippage | {cm.slippage:.2%} |\n"
            f"| Taker Fee | {cm.taker_fee:.2%} | Funding (8h) | {cm.funding_rate_8h:.2%} |\n"
            f"| Market Impact | {cm.market_impact:.2%} | **편도 합계** | **~{total:.2%}** |"
        )

    # ─── Dynamic sections ─────────────────────────────────────────

    def _strategy_summary(self, total: int, active: int, retired: int) -> str:
        return f"## 현재 전략 현황 ({total}개 = 활성 {active} + 폐기 {retired})"

    def _active_table(self, active: list[StrategyRecord]) -> str:
        if not active:
            return "### 활성 전략 (0개)"

        lines = [
            f"### 활성 전략 ({len(active)}개, Gate 5 완료)\n",
            "| 전략 | Best Asset | TF | Sharpe | CAGR | MDD | Trades | G0 | G1 | G2 | G3 | G4 | G5 | 비고 |",
            "|------|-----------|-----|--------|------|-----|--------|:--:|:--:|:--:|:--:|:--:|:--:|------|",
        ]

        for r in sorted(active, key=lambda x: -(x.best_sharpe or 0)):
            best = max(r.asset_performance, key=lambda a: a.sharpe) if r.asset_performance else None
            if best:
                gates_str = " | ".join(
                    _gate_letter(r, gid)
                    for gid in [GateId.G0A, GateId.G1, GateId.G2, GateId.G3, GateId.G4, GateId.G5]
                )
                note = _extract_note(r)
                cagr = f"+{best.cagr:.1f}%" if best.cagr > 0 else f"{best.cagr:.1f}%"
                row = (
                    f"| **{r.meta.display_name}** | {best.symbol} | {r.meta.timeframe} | "
                    + f"{best.sharpe:.2f} | {cagr} | -{best.mdd:.1f}% | {best.trades} | "
                    + f"{gates_str} | {note} |"
                )
                lines.append(row)

        # 활성 전략 상세 노트 (마지막 decision의 rationale)
        notes = []
        for r in sorted(active, key=lambda x: -(x.best_sharpe or 0)):
            last_decision = r.decisions[-1] if r.decisions else None
            if last_decision:
                notes.append(f"> **{r.meta.display_name}**: {last_decision.rationale}")
        if notes:
            lines.append("")
            lines.extend(notes)

        return "\n".join(lines)

    def _retired_sections(self, retired: list[StrategyRecord]) -> str:
        """폐기 전략을 fail gate별로 분류."""
        sections: list[str] = [f"### 폐기 전략 ({len(retired)}개)\n"]
        gate_groups = self.group_retired(retired)
        self._append_group_tables(gate_groups, sections)
        return "\n\n".join(sections)

    def group_retired(
        self,
        retired: list[StrategyRecord],
    ) -> dict[str, list[StrategyRecord]]:
        """폐기 전략을 fail gate별 그룹으로 분류."""
        groups: dict[str, list[StrategyRecord]] = {
            "G4": [],
            "G3": [],
            "G2": [],
            "G1_sharpe": [],
            "G1_negative": [],
            "G1_data": [],
            "G1_structural": [],
        }
        gate_map = {"G4": "G4", "G3": "G3", "G2": "G2"}
        for r in retired:
            fg = r.fail_gate
            if fg in gate_map:
                groups[gate_map[fg]].append(r)
            elif fg == "G1":
                self._classify_g1_fail(r, groups)
            else:
                groups["G1_structural"].append(r)
        return groups

    def _append_group_tables(
        self,
        groups: dict[str, list[StrategyRecord]],
        sections: list[str],
    ) -> None:
        """그룹별 테이블을 sections에 추가."""
        renderers = [
            ("G4", self._g4_fail_table),
            ("G3", self._g3_fail_table),
            ("G2", self._g2_fail_table),
            ("G1_sharpe", self._g1_sharpe_fail_table),
            ("G1_negative", self._g1_negative_fail_table),
            ("G1_data", self._g1_data_fail_table),
            ("G1_structural", self._g1_structural_fail_table),
        ]
        for key, renderer in renderers:
            if groups[key]:
                sections.append(renderer(groups[key]))

    def _classify_g1_fail(
        self,
        r: StrategyRecord,
        groups: dict[str, list[StrategyRecord]],
    ) -> None:
        """G1 FAIL 전략을 세부 카테고리로 분류."""
        if not r.asset_performance:
            groups["G1_data"].append(r)
            return

        best = max(r.asset_performance, key=lambda a: a.sharpe)

        # All negative or near-zero
        all_negative = all(a.sharpe <= 0 for a in r.asset_performance)
        if all_negative or best.sharpe < 0:
            groups["G1_negative"].append(r)
        elif best.sharpe < 1.0 and best.cagr > 0:
            groups["G1_sharpe"].append(r)
        else:
            groups["G1_structural"].append(r)

    def _g4_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Gate 4 실패 -- WFA 심층검증\n",
            "| 전략 | Sharpe | 사유 |",
            "|------|--------|------|",
        ]
        for r in sorted(records, key=lambda x: -(x.best_sharpe or 0)):
            link = r.meta.display_name
            sharpe = f"{r.best_sharpe:.2f}" if r.best_sharpe else "-"
            note = _fail_rationale(r, GateId.G4)
            lines.append(f"| {link} | {sharpe} | {note} |")
        return "\n".join(lines)

    def _g3_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Gate 3 실패 -- 파라미터 불안정\n",
            "| 전략 | Sharpe | 사유 |",
            "|------|--------|------|",
        ]
        for r in records:
            link = r.meta.display_name
            sharpe = f"{r.best_sharpe:.2f}" if r.best_sharpe else "-"
            note = _fail_rationale(r, GateId.G3)
            lines.append(f"| {link} | {sharpe} | {note} |")
        return "\n".join(lines)

    def _g2_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            f"#### Gate 2 실패 -- IS/OOS 과적합 ({len(records)}개)\n",
            "| 전략 | Sharpe | OOS Sharpe | Decay |",
            "|------|--------|-----------|-------|",
        ]
        for r in sorted(records, key=lambda x: -(x.best_sharpe or 0)):
            link = r.meta.display_name
            sharpe = f"{r.best_sharpe:.2f}" if r.best_sharpe else "-"
            g2 = r.gates.get(GateId.G2)
            oos = f"{g2.details.get('oos_sharpe', '-')}" if g2 else "-"
            decay = f"{g2.details.get('decay', '-')}%" if g2 and "decay" in g2.details else "-"
            lines.append(f"| {link} | {sharpe} | {oos} | {decay} |")
        return "\n".join(lines)

    def _g1_sharpe_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Gate 1 실패 -- Sharpe/CAGR 미달\n",
            "| 전략 | Sharpe | CAGR | 사유 |",
            "|------|--------|------|------|",
        ]
        for r in sorted(records, key=lambda x: -(x.best_sharpe or 0)):
            link = r.meta.display_name
            best = max(r.asset_performance, key=lambda a: a.sharpe) if r.asset_performance else None
            sharpe = f"{best.sharpe:.2f}" if best else "-"
            cagr = (
                f"+{best.cagr:.1f}%"
                if best and best.cagr > 0
                else (f"{best.cagr:.1f}%" if best else "-")
            )
            note = _fail_rationale(r, GateId.G1)
            lines.append(f"| {link} | {sharpe} | {cagr} | {note} |")
        return "\n".join(lines)

    def _g1_negative_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Gate 1 실패 -- 전 에셋 Sharpe 음수/0 근접\n",
            "| 전략 | Sharpe | CAGR | 사유 |",
            "|------|--------|------|------|",
        ]
        for r in sorted(records, key=lambda x: -(x.best_sharpe or 0)):
            link = r.meta.display_name
            best = max(r.asset_performance, key=lambda a: a.sharpe) if r.asset_performance else None
            sharpe = f"{best.sharpe:.2f}" if best else "-"
            cagr = (
                f"+{best.cagr:.1f}%"
                if best and best.cagr > 0
                else (f"{best.cagr:.1f}%" if best else "-")
            )
            note = _fail_rationale(r, GateId.G1)
            lines.append(f"| {link} | {sharpe} | {cagr} | {note} |")
        return "\n".join(lines)

    def _g1_data_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Gate 1 실패 -- 데이터 부재 / 인프라 미구축\n",
            "| 전략 | G0 점수 | 사유 |",
            "|------|---------|------|",
        ]
        for r in records:
            link = r.meta.display_name
            g0 = r.gates.get(GateId.G0A)
            score = f"{g0.details.get('score', '?')}/30" if g0 else "-"
            note = _fail_rationale(r, GateId.G1)
            lines.append(f"| {link} | {score} | {note} |")
        return "\n".join(lines)

    def _g1_structural_fail_table(self, records: list[StrategyRecord]) -> str:
        lines = [
            "#### Gate 1 실패 -- 구조적 결함\n",
            "| 전략 | Sharpe | 사유 |",
            "|------|--------|------|",
        ]
        for r in records:
            link = r.meta.display_name
            sharpe = f"{r.best_sharpe:.2f}" if r.best_sharpe else "-"
            note = _fail_rationale(r, GateId.G1)
            lines.append(f"| {link} | {sharpe} | {note} |")
        return "\n".join(lines)

    def _lessons(self) -> str:
        """핵심 교훈 (LessonStore에서 생성)."""
        if self.lesson_store is not None:
            return self._generate_lessons_table()
        return ""

    def _generate_lessons_table(self) -> str:
        """LessonStore → markdown 테이블 생성."""
        assert self.lesson_store is not None
        records = self.lesson_store.load_all()
        if not records:
            return "## 핵심 교훈\n\n(없음)"
        lines = [
            "## 핵심 교훈\n",
            "| # | 교훈 |",
            "|---|------|",
            *[f"| {r.id} | **{r.title}**: {r.body} |" for r in records],
        ]
        return "\n".join(lines)


# ─── Helpers ─────────────────────────────────────────────────────────


def _summarize_criteria(g: GateCriteria) -> str:
    """GateCriteria → 1줄 요약 텍스트."""
    if g.gate_type == GateType.SCORING and g.scoring:
        n = len(g.scoring.items)
        return f"{n}항목 합계 >= {g.scoring.pass_threshold}/{g.scoring.max_total}"
    if g.gate_type == GateType.CHECKLIST and g.checklist:
        return g.checklist.pass_rule
    if g.gate_type == GateType.THRESHOLD and g.threshold:
        parts = []
        for m in g.threshold.pass_metrics:
            val_str = str(int(m.value)) if m.value == int(m.value) else str(m.value)
            parts.append(f"{m.name} {m.operator} {val_str}{m.unit}")
        return ", ".join(parts)
    return ""


def _gate_letter(record: StrategyRecord, gid: GateId) -> str:
    """Gate 결과를 P/F/- 단일 문자로."""
    result = record.gates.get(gid)
    if result is None:
        return " "
    return "P" if result.status == GateVerdict.PASS else "F"


def _extract_note(record: StrategyRecord) -> str:
    """활성 전략의 비고."""
    g4 = record.gates.get(GateId.G4)
    if g4 and "note" in g4.details:
        return str(g4.details["note"])
    return ""


def _fail_rationale(record: StrategyRecord, gate: GateId) -> str:
    """FAIL 사유 추출 — decisions.rationale 우선."""
    # 1. decisions에서 해당 gate의 rationale 탐색
    for d in reversed(record.decisions):
        if d.gate == gate:
            return d.rationale

    # 2. fallback: gates.details
    result = record.gates.get(gate)
    if not result:
        return ""
    note = result.details.get("note", "")
    if note:
        return str(note)
    # Build from structured details
    parts = []
    if "sharpe" in result.details:
        parts.append(f"Sharpe {result.details['sharpe']}")
    if "cagr" in result.details:
        parts.append(f"CAGR {result.details['cagr']}%")
    return ", ".join(parts) if parts else ""


def _gate_badge(record: StrategyRecord, gid: GateId) -> str:
    """Gate 결과를 Rich 색상 문자로 변환."""
    result = record.gates.get(gid)
    if result is None:
        return "[dim]-[/dim]"
    if result.status == GateVerdict.PASS:
        return "[green]P[/green]"
    return "[red]F[/red]"


_GATE_DISPLAY = ("G0A", "G0B", "G1", "G2", "G3", "G4", "G5", "G6", "G7")

_RETIRED_GROUP_LABELS: dict[str, str] = {
    "G4": "G4 WFA 심층검증",
    "G3": "G3 파라미터 불안정",
    "G2": "G2 IS/OOS 과적합",
    "G1_sharpe": "G1 Sharpe/CAGR 미달",
    "G1_negative": "G1 전 에셋 Sharpe 음수",
    "G1_data": "G1 데이터 부재",
    "G1_structural": "G1 구조적 결함",
}


class ConsoleRenderer:
    """YAML 데이터 → Rich 콘솔 출력."""

    def __init__(
        self,
        store: StrategyStore,
        lesson_store: LessonStore | None = None,
        gate_store: GateCriteriaStore | None = None,
        console: Console | None = None,
    ) -> None:
        self.store = store
        self.lesson_store = lesson_store
        self.gate_store = gate_store
        self.console = console or Console()

    def render(self) -> None:
        """콘솔에 전략 상황판 출력."""
        records = self.store.load_all()
        active = [r for r in records if r.meta.status == StrategyStatus.ACTIVE]
        retired = [r for r in records if r.meta.status == StrategyStatus.RETIRED]

        self._render_header(len(records), len(active), len(retired))
        self._render_active(active)
        self._render_retired_summary(retired)
        self._render_lessons()

    def _render_header(self, total: int, active: int, retired: int) -> None:
        self.console.print()
        self.console.print("[bold]Strategy Dashboard[/bold]")
        line = f"  [green]Active: {active}[/green] | [red]Retired: {retired}[/red] | Total: {total}"
        self.console.print(line)

    def _render_active(self, active: list[StrategyRecord]) -> None:
        if not active:
            self.console.print("\n[yellow]No active strategies.[/yellow]")
            return

        table = Table(
            title=f"Active Strategies ({len(active)})",
            show_header=True,
            header_style="bold",
            show_lines=False,
        )
        table.add_column("Strategy", style="bold", min_width=12)
        table.add_column("Best Asset", width=11)
        table.add_column("TF", width=4)
        table.add_column("Sharpe", justify="right", width=7)
        table.add_column("CAGR", justify="right", width=8)
        table.add_column("MDD", justify="right", width=7)
        table.add_column("Trades", justify="right", width=7)
        for gname in _GATE_DISPLAY:
            table.add_column(gname, justify="center", width=3)

        for r in sorted(active, key=lambda x: -(x.best_sharpe or 0)):
            best = max(r.asset_performance, key=lambda a: a.sharpe) if r.asset_performance else None
            if not best:
                continue
            cagr = f"+{best.cagr:.1f}%" if best.cagr > 0 else f"{best.cagr:.1f}%"
            gate_cells = [_gate_badge(r, GateId(g)) for g in _GATE_DISPLAY]
            table.add_row(
                r.meta.display_name,
                best.symbol,
                r.meta.timeframe,
                f"{best.sharpe:.2f}",
                cagr,
                f"-{best.mdd:.1f}%",
                str(best.trades),
                *gate_cells,
            )

        self.console.print()
        self.console.print(table)

        # 활성 전략 노트
        for r in sorted(active, key=lambda x: -(x.best_sharpe or 0)):
            last = r.decisions[-1] if r.decisions else None
            if last:
                self.console.print(f"  [dim]{r.meta.display_name}:[/dim] {last.rationale}")

    def _render_retired_summary(self, retired: list[StrategyRecord]) -> None:
        if not retired:
            return

        gen = DashboardGenerator(self.store)
        groups = gen.group_retired(retired)

        self.console.print()
        self.console.print(f"[bold]Retired Strategies ({len(retired)})[/bold]")

        parts = []
        for key, label in _RETIRED_GROUP_LABELS.items():
            count = len(groups.get(key, []))
            if count:
                parts.append(f"  {label}: {count}")
        self.console.print("\n".join(parts))

    def _render_lessons(self) -> None:
        if self.lesson_store is None:
            return
        records = self.lesson_store.load_all()
        if not records:
            return

        table = Table(
            title=f"Lessons ({len(records)})",
            show_header=True,
            header_style="bold",
            show_lines=False,
        )
        table.add_column("#", style="dim", width=3)
        table.add_column("Title", style="bold", min_width=20)
        table.add_column("Category", width=18)

        for r in records:
            table.add_row(str(r.id), r.title, r.category.value)

        self.console.print()
        self.console.print(table)
